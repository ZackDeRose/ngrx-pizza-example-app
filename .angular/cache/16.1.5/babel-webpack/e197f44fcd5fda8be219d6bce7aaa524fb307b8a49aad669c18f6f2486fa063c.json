{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, inject, Injectable, ChangeDetectorRef, untracked, Directive, Input, NgModule, Pipe } from '@angular/core';\nimport { isObservable, combineLatest, from, Observable, ReplaySubject, pipe, Subscription } from 'rxjs';\nimport { distinctUntilChanged, tap, switchMap } from 'rxjs/operators';\nfunction isNgZone(zone) {\n  return zone instanceof NgZone;\n}\nlet TickScheduler = /*#__PURE__*/(() => {\n  class TickScheduler {}\n  /** @nocollapse */TickScheduler.Éµfac = function TickScheduler_Factory(t) {\n    return new (t || TickScheduler)();\n  };\n  /** @nocollapse */TickScheduler.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n    token: TickScheduler,\n    factory: function () {\n      return (() => {\n        const zone = inject(NgZone);\n        return isNgZone(zone) ? new NoopTickScheduler() : inject(AnimationFrameTickScheduler);\n      })();\n    },\n    providedIn: 'root'\n  });\n  return TickScheduler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnimationFrameTickScheduler = /*#__PURE__*/(() => {\n  class AnimationFrameTickScheduler extends TickScheduler {\n    constructor(appRef) {\n      super();\n      this.appRef = appRef;\n      this.isScheduled = false;\n    }\n    schedule() {\n      if (!this.isScheduled) {\n        this.isScheduled = true;\n        requestAnimationFrame(() => {\n          this.appRef.tick();\n          this.isScheduled = false;\n        });\n      }\n    }\n    /** @nocollapse */\n  }\n  AnimationFrameTickScheduler.Éµfac = function AnimationFrameTickScheduler_Factory(t) {\n    return new (t || AnimationFrameTickScheduler)(i0.ÉµÉµinject(i0.ApplicationRef));\n  };\n  /** @nocollapse */AnimationFrameTickScheduler.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n    token: AnimationFrameTickScheduler,\n    factory: AnimationFrameTickScheduler.Éµfac,\n    providedIn: 'root'\n  });\n  return AnimationFrameTickScheduler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass NoopTickScheduler extends TickScheduler {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  schedule() {}\n}\n\n/**\n * Provides rendering functionality regardless of whether `zone.js` is present\n * or not. It must be provided at the component/directive level.\n *\n * @usageNotes\n *\n * ### Rerender zone-less app on route changes\n *\n * ```ts\n * @Component({\n *   selector: 'app-root',\n *   template: '<router-outlet>',\n *   // ðŸ‘‡ `RenderScheduler` is provided at the component level\n *   providers: [RenderScheduler],\n *   changeDetection: ChangeDetectionStrategy.OnPush,\n * })\n * export class AppComponent implements OnInit {\n *   constructor(\n *     private readonly router: Router,\n *     private readonly renderScheduler: RenderScheduler\n *   ) {}\n *\n *   ngOnInit(): void {\n *     this.router.events\n *       .pipe(filter((e) => e instanceof NavigationEnd))\n *       .subscribe(() => this.renderScheduler.schedule());\n *   }\n * }\n * ```\n *\n * ### Rerender component on interval\n *\n * ```ts\n * @Component({\n *   selector: 'app-interval',\n *   template: '{{ elapsedTime }}ms',\n *   // ðŸ‘‡ `RenderScheduler` is provided at the component level\n *   providers: [RenderScheduler],\n *   changeDetection: ChangeDetectionStrategy.OnPush,\n * })\n * export class IntervalComponent implements OnInit {\n *   elapsedTime = 0;\n *\n *   constructor(private readonly renderScheduler: RenderScheduler) {}\n *\n *   ngOnInit(): void {\n *     setInterval(() => {\n *       this.elapsedTime += 1000;\n *       this.renderScheduler.schedule();\n *     }, 1000);\n *   }\n * }\n * ```\n */\nlet RenderScheduler = /*#__PURE__*/(() => {\n  class RenderScheduler {\n    constructor(cdRef, tickScheduler) {\n      this.cdRef = cdRef;\n      this.tickScheduler = tickScheduler;\n    }\n    /**\n     * Marks component and its ancestors as dirty.\n     * It also schedules a new change detection cycle in zone-less mode.\n     */\n    schedule() {\n      this.cdRef.markForCheck();\n      this.tickScheduler.schedule();\n    }\n    /** @nocollapse */\n  }\n  RenderScheduler.Éµfac = function RenderScheduler_Factory(t) {\n    return new (t || RenderScheduler)(i0.ÉµÉµinject(i0.ChangeDetectorRef), i0.ÉµÉµinject(TickScheduler));\n  };\n  /** @nocollapse */RenderScheduler.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n    token: RenderScheduler,\n    factory: RenderScheduler.Éµfac\n  });\n  return RenderScheduler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction createRenderScheduler() {\n  return new RenderScheduler(inject(ChangeDetectorRef), inject(TickScheduler));\n}\nfunction combineRenderEventHandlers(handlers) {\n  return event => handlers[event.type]?.(event);\n}\nfunction fromPotentialObservable(potentialObservable) {\n  if (isObservable(potentialObservable)) {\n    return potentialObservable;\n  }\n  if (isObservableDictionary(potentialObservable)) {\n    return combineLatest(toDistinctObsDictionary(potentialObservable));\n  }\n  if (isPromiseLike(potentialObservable)) {\n    return from(potentialObservable);\n  }\n  return new Observable(subscriber => {\n    subscriber.next(potentialObservable);\n  });\n}\nfunction isPromiseLike(value) {\n  return typeof value?.then === 'function';\n}\nfunction isObservableDictionary(value) {\n  return isDictionary(value) && Object.keys(value).length > 0 && Object.values(value).every(isObservable);\n}\nfunction isDictionary(value) {\n  return !!value && typeof value === 'object' && !Array.isArray(value);\n}\nfunction toDistinctObsDictionary(obsDictionary) {\n  return Object.keys(obsDictionary).reduce((acc, key) => ({\n    ...acc,\n    [key]: obsDictionary[key].pipe(distinctUntilChanged())\n  }), {});\n}\nfunction createRenderEventManager(handlers) {\n  const handleRenderEvent = combineRenderEventHandlers(handlers);\n  const potentialObservable$ = new ReplaySubject(1);\n  return {\n    nextPotentialObservable(potentialObservable) {\n      potentialObservable$.next(potentialObservable);\n    },\n    handlePotentialObservableChanges() {\n      return potentialObservable$.pipe(distinctUntilChanged(), switchMapToRenderEvent(), distinctUntilChanged(renderEventComparator), tap(handleRenderEvent));\n    }\n  };\n}\nfunction switchMapToRenderEvent() {\n  return pipe(switchMap(potentialObservable => {\n    const observable$ = fromPotentialObservable(potentialObservable);\n    let reset = true;\n    let synchronous = true;\n    return new Observable(subscriber => {\n      const subscription = untracked(() => observable$.subscribe({\n        next(value) {\n          subscriber.next({\n            type: 'next',\n            value,\n            reset,\n            synchronous\n          });\n          reset = false;\n        },\n        error(error) {\n          subscriber.next({\n            type: 'error',\n            error,\n            reset,\n            synchronous\n          });\n          reset = false;\n        },\n        complete() {\n          subscriber.next({\n            type: 'complete',\n            reset,\n            synchronous\n          });\n          reset = false;\n        }\n      }));\n      if (reset) {\n        subscriber.next({\n          type: 'suspense',\n          reset,\n          synchronous: true\n        });\n        reset = false;\n      }\n      synchronous = false;\n      return subscription;\n    });\n  }));\n}\nfunction renderEventComparator(previous, current) {\n  if (previous.type !== current.type || previous.reset !== current.reset) {\n    return false;\n  }\n  if (current.type === 'next') {\n    return previous.value === current.value;\n  }\n  if (current.type === 'error') {\n    return previous.error === current.error;\n  }\n  return true;\n}\n\n/**\n * @ngModule LetModule\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context\n * (DOM element's scope). It also helps with several internal processing under the hood.\n *\n * @usageNotes\n *\n * ### Displaying Observable Values\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"number$; let n\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n * ```\n *\n * ### Tracking Different Observable Events\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n; error as e; complete as c\">\n *   <app-number [number]=\"n\" *ngIf=\"!e && !c\">\n *   </app-number>\n *\n *   <p *ngIf=\"e\">There is an error: {{ e }}</p>\n *   <p *ngIf=\"c\">Observable is completed.</p>\n * </ng-container>\n * ```\n *\n * ### Combining Multiple Observables\n *\n * ```html\n * <ng-container *ngrxLet=\"{ users: users$, query: query$ } as vm\">\n *   <app-search-bar [query]=\"vm.query\"></app-search-bar>\n *   <app-user-list [users]=\"vm.users\"></app-user-list>\n * </ng-container>\n * ```\n *\n * ### Using Suspense Template\n *\n * ```html\n * <ng-container *ngrxLet=\"number$ as n; suspenseTpl: loading\">\n *   <app-number [number]=\"n\"></app-number>\n * </ng-container>\n *\n * <ng-template #loading>\n *   <p>Loading...</p>\n * </ng-template>\n * ```\n *\n * ### Using Aliases for Non-Observable Values\n *\n * ```html\n * <ng-container *ngrxLet=\"userForm.controls.email as email\">\n *   <input type=\"text\" [formControl]=\"email\" />\n *\n *   <ng-container *ngIf=\"email.errors && (email.touched || email.dirty)\">\n *     <p *ngIf=\"email.errors.required\">This field is required.</p>\n *     <p *ngIf=\"email.errors.email\">This field must be an email.</p>\n *   </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\nlet LetDirective = /*#__PURE__*/(() => {\n  class LetDirective {\n    set ngrxLet(potentialObservable) {\n      this.renderEventManager.nextPotentialObservable(potentialObservable);\n    }\n    constructor(mainTemplateRef, viewContainerRef, errorHandler, renderScheduler) {\n      this.mainTemplateRef = mainTemplateRef;\n      this.viewContainerRef = viewContainerRef;\n      this.errorHandler = errorHandler;\n      this.renderScheduler = renderScheduler;\n      this.isMainViewCreated = false;\n      this.isSuspenseViewCreated = false;\n      this.viewContext = {\n        $implicit: undefined,\n        ngrxLet: undefined,\n        error: undefined,\n        complete: false\n      };\n      this.renderEventManager = createRenderEventManager({\n        suspense: () => {\n          this.viewContext.$implicit = undefined;\n          this.viewContext.ngrxLet = undefined;\n          this.viewContext.error = undefined;\n          this.viewContext.complete = false;\n          this.renderSuspenseView();\n        },\n        next: event => {\n          this.viewContext.$implicit = event.value;\n          this.viewContext.ngrxLet = event.value;\n          if (event.reset) {\n            this.viewContext.error = undefined;\n            this.viewContext.complete = false;\n          }\n          this.renderMainView(event.synchronous);\n        },\n        error: event => {\n          this.viewContext.error = event.error;\n          if (event.reset) {\n            this.viewContext.$implicit = undefined;\n            this.viewContext.ngrxLet = undefined;\n            this.viewContext.complete = false;\n          }\n          this.renderMainView(event.synchronous);\n          this.errorHandler.handleError(event.error);\n        },\n        complete: event => {\n          this.viewContext.complete = true;\n          if (event.reset) {\n            this.viewContext.$implicit = undefined;\n            this.viewContext.ngrxLet = undefined;\n            this.viewContext.error = undefined;\n          }\n          this.renderMainView(event.synchronous);\n        }\n      });\n      this.subscription = new Subscription();\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n    ngOnInit() {\n      this.subscription.add(this.renderEventManager.handlePotentialObservableChanges().subscribe());\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    renderMainView(isSyncEvent) {\n      if (this.isSuspenseViewCreated) {\n        this.isSuspenseViewCreated = false;\n        this.viewContainerRef.clear();\n      }\n      if (!this.isMainViewCreated) {\n        this.isMainViewCreated = true;\n        this.viewContainerRef.createEmbeddedView(this.mainTemplateRef, this.viewContext);\n      }\n      if (!isSyncEvent) {\n        this.renderScheduler.schedule();\n      }\n    }\n    renderSuspenseView() {\n      if (this.isMainViewCreated) {\n        this.isMainViewCreated = false;\n        this.viewContainerRef.clear();\n      }\n      if (this.suspenseTemplateRef && !this.isSuspenseViewCreated) {\n        this.isSuspenseViewCreated = true;\n        this.viewContainerRef.createEmbeddedView(this.suspenseTemplateRef);\n      }\n    }\n    /** @nocollapse */\n  }\n  LetDirective.Éµfac = function LetDirective_Factory(t) {\n    return new (t || LetDirective)(i0.ÉµÉµdirectiveInject(i0.TemplateRef), i0.ÉµÉµdirectiveInject(i0.ViewContainerRef), i0.ÉµÉµdirectiveInject(i0.ErrorHandler), i0.ÉµÉµdirectiveInject(RenderScheduler));\n  };\n  /** @nocollapse */LetDirective.Éµdir = /* @__PURE__ */i0.ÉµÉµdefineDirective({\n    type: LetDirective,\n    selectors: [[\"\", \"ngrxLet\", \"\"]],\n    inputs: {\n      ngrxLet: \"ngrxLet\",\n      suspenseTemplateRef: [\"ngrxLetSuspenseTpl\", \"suspenseTemplateRef\"]\n    },\n    standalone: true,\n    features: [i0.ÉµÉµProvidersFeature([RenderScheduler])]\n  });\n  return LetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated This module is deprecated in favor of the standalone `LetDirective`.\n */\nlet LetModule = /*#__PURE__*/(() => {\n  class LetModule {}\n  /** @nocollapse */LetModule.Éµfac = function LetModule_Factory(t) {\n    return new (t || LetModule)();\n  };\n  /** @nocollapse */LetModule.Éµmod = /* @__PURE__ */i0.ÉµÉµdefineNgModule({\n    type: LetModule\n  });\n  /** @nocollapse */LetModule.Éµinj = /* @__PURE__ */i0.ÉµÉµdefineInjector({});\n  return LetModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @ngModule PushModule\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * @usageNotes\n *\n * ### Displaying Observable Values\n *\n * ```html\n * <p>{{ number$ | ngrxPush }}</p>\n *\n * <ng-container *ngIf=\"number$ | ngrxPush as n\">{{ n }}</ng-container>\n *\n * <app-number [number]=\"number$ | ngrxPush\"></app-number>\n * ```\n *\n * ### Combining Multiple Observables\n *\n * ```html\n * <code>\n *   {{ { users: users$, query: query$ } | ngrxPush | json }}\n * </code>\n * ```\n *\n * @publicApi\n */\nlet PushPipe = /*#__PURE__*/(() => {\n  class PushPipe {\n    constructor(errorHandler) {\n      this.errorHandler = errorHandler;\n      this.renderScheduler = createRenderScheduler();\n      this.renderEventManager = createRenderEventManager({\n        suspense: event => this.setRenderedValue(undefined, event.synchronous),\n        next: event => this.setRenderedValue(event.value, event.synchronous),\n        error: event => {\n          if (event.reset) {\n            this.setRenderedValue(undefined, event.synchronous);\n          }\n          this.errorHandler.handleError(event.error);\n        },\n        complete: event => {\n          if (event.reset) {\n            this.setRenderedValue(undefined, event.synchronous);\n          }\n        }\n      });\n      this.subscription = this.renderEventManager.handlePotentialObservableChanges().subscribe();\n    }\n    transform(potentialObservable) {\n      this.renderEventManager.nextPotentialObservable(potentialObservable);\n      return this.renderedValue;\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    setRenderedValue(value, isSyncEvent) {\n      if (value !== this.renderedValue) {\n        this.renderedValue = value;\n        if (!isSyncEvent) {\n          this.renderScheduler.schedule();\n        }\n      }\n    }\n    /** @nocollapse */\n  }\n  PushPipe.Éµfac = function PushPipe_Factory(t) {\n    return new (t || PushPipe)(i0.ÉµÉµdirectiveInject(i0.ErrorHandler, 16));\n  };\n  /** @nocollapse */PushPipe.Éµpipe = /* @__PURE__ */i0.ÉµÉµdefinePipe({\n    name: \"ngrxPush\",\n    type: PushPipe,\n    pure: false,\n    standalone: true\n  });\n  return PushPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated This module is deprecated in favor of the standalone `PushPipe`.\n */\nlet PushModule = /*#__PURE__*/(() => {\n  class PushModule {}\n  /** @nocollapse */PushModule.Éµfac = function PushModule_Factory(t) {\n    return new (t || PushModule)();\n  };\n  /** @nocollapse */PushModule.Éµmod = /* @__PURE__ */i0.ÉµÉµdefineNgModule({\n    type: PushModule\n  });\n  /** @nocollapse */PushModule.Éµinj = /* @__PURE__ */i0.ÉµÉµdefineInjector({});\n  return PushModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LetDirective, LetModule, PushModule, PushPipe, RenderScheduler };\n//# sourceMappingURL=ngrx-component.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}